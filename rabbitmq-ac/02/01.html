<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>相关概念介绍 | MQ 系列教程（笔记）</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="MQ 系列教程学习笔记">
    <link rel="preload" href="/mq-tutorial/assets/css/0.styles.172db5bd.css" as="style"><link rel="preload" href="/mq-tutorial/assets/js/app.fccc8b77.js" as="script"><link rel="preload" href="/mq-tutorial/assets/js/2.69dbb0e8.js" as="script"><link rel="preload" href="/mq-tutorial/assets/js/3.6c91dad7.js" as="script"><link rel="preload" href="/mq-tutorial/assets/js/5.8981dd5c.js" as="script"><link rel="prefetch" href="/mq-tutorial/assets/js/10.48a73447.js"><link rel="prefetch" href="/mq-tutorial/assets/js/11.1c3dec41.js"><link rel="prefetch" href="/mq-tutorial/assets/js/12.2330206e.js"><link rel="prefetch" href="/mq-tutorial/assets/js/13.cd520efb.js"><link rel="prefetch" href="/mq-tutorial/assets/js/14.6a4b32b8.js"><link rel="prefetch" href="/mq-tutorial/assets/js/15.8a7cfdec.js"><link rel="prefetch" href="/mq-tutorial/assets/js/16.d397de71.js"><link rel="prefetch" href="/mq-tutorial/assets/js/17.1a879f70.js"><link rel="prefetch" href="/mq-tutorial/assets/js/18.9214e1ad.js"><link rel="prefetch" href="/mq-tutorial/assets/js/19.25151ad1.js"><link rel="prefetch" href="/mq-tutorial/assets/js/20.25449e14.js"><link rel="prefetch" href="/mq-tutorial/assets/js/21.d7b2f119.js"><link rel="prefetch" href="/mq-tutorial/assets/js/22.cd699d61.js"><link rel="prefetch" href="/mq-tutorial/assets/js/23.ed2d7edb.js"><link rel="prefetch" href="/mq-tutorial/assets/js/24.c1dabc94.js"><link rel="prefetch" href="/mq-tutorial/assets/js/25.93f9e52b.js"><link rel="prefetch" href="/mq-tutorial/assets/js/26.1229fbbe.js"><link rel="prefetch" href="/mq-tutorial/assets/js/27.28d8d025.js"><link rel="prefetch" href="/mq-tutorial/assets/js/28.fdf6967b.js"><link rel="prefetch" href="/mq-tutorial/assets/js/29.17cf9046.js"><link rel="prefetch" href="/mq-tutorial/assets/js/30.e6e0e489.js"><link rel="prefetch" href="/mq-tutorial/assets/js/31.c0ddc735.js"><link rel="prefetch" href="/mq-tutorial/assets/js/32.b7c34b84.js"><link rel="prefetch" href="/mq-tutorial/assets/js/33.89168609.js"><link rel="prefetch" href="/mq-tutorial/assets/js/34.054e64a8.js"><link rel="prefetch" href="/mq-tutorial/assets/js/35.e6bf56ed.js"><link rel="prefetch" href="/mq-tutorial/assets/js/36.bb0253c4.js"><link rel="prefetch" href="/mq-tutorial/assets/js/37.8be0005d.js"><link rel="prefetch" href="/mq-tutorial/assets/js/38.d09f952d.js"><link rel="prefetch" href="/mq-tutorial/assets/js/39.59e1ba94.js"><link rel="prefetch" href="/mq-tutorial/assets/js/4.b94a031d.js"><link rel="prefetch" href="/mq-tutorial/assets/js/40.1f94011a.js"><link rel="prefetch" href="/mq-tutorial/assets/js/41.bf0e5a2a.js"><link rel="prefetch" href="/mq-tutorial/assets/js/42.8a84461a.js"><link rel="prefetch" href="/mq-tutorial/assets/js/43.e3d0ef27.js"><link rel="prefetch" href="/mq-tutorial/assets/js/6.88db02fa.js"><link rel="prefetch" href="/mq-tutorial/assets/js/7.07ac47e8.js"><link rel="prefetch" href="/mq-tutorial/assets/js/8.ec1d24c2.js"><link rel="prefetch" href="/mq-tutorial/assets/js/9.2af0fa3d.js">
    <link rel="stylesheet" href="/mq-tutorial/assets/css/0.styles.172db5bd.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/mq-tutorial/" class="home-link router-link-active"><!----> <span class="site-name">MQ 系列教程（笔记）</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/mq-tutorial/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/mq-tutorial/rabbitmq-ac/" class="nav-link router-link-active">
  RabbitMq 实战指南
</a></div><div class="nav-item"><a href="https://github.com/zq99299/repository-summary" target="_blank" rel="noopener noreferrer" class="nav-link external">
  笔记精选汇总
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/zq99299/mq-tutorial" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/mq-tutorial/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/mq-tutorial/rabbitmq-ac/" class="nav-link router-link-active">
  RabbitMq 实战指南
</a></div><div class="nav-item"><a href="https://github.com/zq99299/repository-summary" target="_blank" rel="noopener noreferrer" class="nav-link external">
  笔记精选汇总
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/zq99299/mq-tutorial" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><a href="/mq-tutorial/rabbitmq-ac/" aria-current="page" class="sidebar-link">RabbitMq 实战指南</a></li><li><a href="/mq-tutorial/rabbitmq-ac/01/" class="sidebar-link">RabbitMQ 简介</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>相关概念介绍</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/mq-tutorial/rabbitmq-ac/" aria-current="page" class="sidebar-link">RabbitMq 实战指南</a></li><li><a href="/mq-tutorial/rabbitmq-ac/02/01.html" aria-current="page" class="active sidebar-link">相关概念介绍</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mq-tutorial/rabbitmq-ac/02/01.html#生产者和消费者" class="sidebar-link">生产者和消费者</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mq-tutorial/rabbitmq-ac/02/01.html#生产者" class="sidebar-link">生产者</a></li><li class="sidebar-sub-header"><a href="/mq-tutorial/rabbitmq-ac/02/01.html#消费者" class="sidebar-link">消费者</a></li><li class="sidebar-sub-header"><a href="/mq-tutorial/rabbitmq-ac/02/01.html#broker" class="sidebar-link">Broker</a></li></ul></li><li class="sidebar-sub-header"><a href="/mq-tutorial/rabbitmq-ac/02/01.html#队列" class="sidebar-link">队列</a></li><li class="sidebar-sub-header"><a href="/mq-tutorial/rabbitmq-ac/02/01.html#交换器、路由键、绑定" class="sidebar-link">交换器、路由键、绑定</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mq-tutorial/rabbitmq-ac/02/01.html#exchange-交换器" class="sidebar-link">Exchange 交换器</a></li><li class="sidebar-sub-header"><a href="/mq-tutorial/rabbitmq-ac/02/01.html#routingkey-路由键" class="sidebar-link">RoutingKey 路由键</a></li><li class="sidebar-sub-header"><a href="/mq-tutorial/rabbitmq-ac/02/01.html#binding-绑定" class="sidebar-link">Binding 绑定</a></li></ul></li><li class="sidebar-sub-header"><a href="/mq-tutorial/rabbitmq-ac/02/01.html#交换器类型" class="sidebar-link">交换器类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mq-tutorial/rabbitmq-ac/02/01.html#fanout" class="sidebar-link">fanout</a></li><li class="sidebar-sub-header"><a href="/mq-tutorial/rabbitmq-ac/02/01.html#direct" class="sidebar-link">direct</a></li><li class="sidebar-sub-header"><a href="/mq-tutorial/rabbitmq-ac/02/01.html#topic" class="sidebar-link">topic</a></li><li class="sidebar-sub-header"><a href="/mq-tutorial/rabbitmq-ac/02/01.html#headers" class="sidebar-link">headers</a></li></ul></li><li class="sidebar-sub-header"><a href="/mq-tutorial/rabbitmq-ac/02/01.html#rabbitmq-的运转流程" class="sidebar-link">RabbitMQ 的运转流程</a></li></ul></li><li><a href="/mq-tutorial/rabbitmq-ac/02/02.html" class="sidebar-link">AQMP 协议介绍</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>客户端开发向导</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>RabbitMQ 进阶</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>RabbitMQ 管理</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>RabbitMQ 配置</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>RRabbitMQ 运维</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="相关概念介绍"><a href="#相关概念介绍" class="header-anchor">#</a> 相关概念介绍</h1> <p>RabbitMQ 整体上是一个 <strong>生产者与消费者模型</strong>，主要负责 <strong>接收、存储和转发消息</strong>。</p> <p><img src="/mq-tutorial/assets/img/image-20200623134112047.9b0e71cd.png" alt="image-20200623134112047"></p> <h2 id="生产者和消费者"><a href="#生产者和消费者" class="header-anchor">#</a> 生产者和消费者</h2> <h3 id="生产者"><a href="#生产者" class="header-anchor">#</a> 生产者</h3> <p>Producer：生产者，投递消息的一方</p> <p>生产者创建消息，发布到 RabbitMQ 中。</p> <p>消息一般可以包含 2 个部分：</p> <ul><li><p>消息体（payload）</p> <p>你的业务数据，比如一个 JSON 字符串</p></li> <li><p>标签（label）：用来描述这条消息</p> <p>比如：一个交换器的名称和一个路由键。RabbitMQ 会根据标签把消息发送给感兴趣的消费者（Consumer）</p></li></ul> <h3 id="消费者"><a href="#消费者" class="header-anchor">#</a> 消费者</h3> <p>Consumer：消费者，接收消息的一方</p> <p>消费者链接到 RabbitMQ，并 <strong>订阅到队列</strong> 上。当消费者消费一条消息时，只是消费消息的 <strong>消息体（payload）</strong>，路由过程中，<strong>消息的标签会丢弃</strong>，<strong>存入到队列中的消息只有消息体</strong>。</p> <p>消费者不知道生产者是谁。</p> <h3 id="broker"><a href="#broker" class="header-anchor">#</a> Broker</h3> <p>Broker：消息中间件的服务节点。</p> <p>对于 RabbitMQ 来说，一个 Broker 可以简单看成一个 RabbitMQ 服务节点，或则 RabbitMQ 服务实例。</p> <p>下图展示了：生产者将消息存入 Broker，以及消费者从 Broker 中消费数据的整个流程</p> <p><img src="/mq-tutorial/assets/img/image-20200623135211410.bc805667.png" alt="image-20200623135211410"></p> <ul><li><p>生产者将消息发送到 Broker 中</p> <p>发送：对应的 AMQP 协议命令为  <code>Basic.Publish</code></p></li> <li><p>消费者订阅并接收消息</p> <p>订阅并接收：对应的 AMQP 协议命令为 <code>Basic.Consume</code> 或 <code>Basic.Get</code></p></li></ul> <h2 id="队列"><a href="#队列" class="header-anchor">#</a> 队列</h2> <p>Queue：队列 ，是 RabbitMQ 的内部对象，用于存储消息。</p> <p>RabbitMQ 中消息都 <strong>只能存储在队列中</strong>，kafka 将消息存储在 topic 这个逻辑层面中，而相对应的队列逻辑知识 topic 实际存储文件中的位置偏移标识。</p> <p><strong>多个消费者可以订阅同一个队列</strong>，这时队列中的消息会被 <strong>平均分摊</strong>（Round-Robin 轮询）给多个消费者进行处理。</p> <p><img src="/mq-tutorial/assets/img/image-20200623140440544.b52ae18f.png" alt="image-20200623140440544"></p> <p>RabbitMQ <strong>不支持队列层面的广播消息</strong>，如果需要广播消费，需要进行二次开发，麻烦，不推荐。</p> <h2 id="交换器、路由键、绑定"><a href="#交换器、路由键、绑定" class="header-anchor">#</a> 交换器、路由键、绑定</h2> <h3 id="exchange-交换器"><a href="#exchange-交换器" class="header-anchor">#</a> Exchange 交换器</h3> <p>在图 2-4 中，消息并不是直接到队列中的，而是消息先到 Exchange（交换器，通常用大写的 X 表示），<strong>由交换器将消息路由到一个或多个队列中</strong>。如果路由不到，或许会返回给生产者，或许会直接丢弃。</p> <p>示意图如下</p> <p><img src="/mq-tutorial/assets/img/image-20200623141205312.ae38e6ea.png" alt="image-20200623141205312"></p> <p>RabbitMQ 中的交换器有 4 种类型，不同的类型有不同的策略，后续详细讲解。</p> <h3 id="routingkey-路由键"><a href="#routingkey-路由键" class="header-anchor">#</a> RoutingKey 路由键</h3> <p>生产者将消息发给交换器时，一般会指定一个 RoutingKey，用来指定这个消息的路由规则。</p> <p>RoutingKey 需要与<strong>交换器类型</strong>和 <strong>绑定键（BindingKey）</strong> 联合使用才能最终生效</p> <h3 id="binding-绑定"><a href="#binding-绑定" class="header-anchor">#</a> Binding 绑定</h3> <p>通过 <strong>绑定</strong> 将 <strong>交换器与队列关联</strong> 起来，绑定时一般会指定一个 <strong>绑定键（BindingKey）</strong>，这样 RabbitMQ 就知道如何正确将消息路由到队列了，示意图如下：</p> <p><img src="/mq-tutorial/assets/img/image-20200623141825523.36e0d71d.png" alt="image-20200623141825523"></p> <p>生产者将消息发送给交换器时，需要一个 RoutingKey，<strong>当 BindingKey 和 RoutingKey 匹配时</strong>，消息被路由到对应的队列中。</p> <p>绑定多个队列到同一个交换器时，BindingKey 允许相同。BindingKey 只能在 <strong>指定的交换器类型下生效</strong>，比如 fanout 类型的交换器就不生效，它将消息路由到所有绑定到该交换器的队列中。</p> <p>其实你已经发现了：在某些情况下，RoutingKey 与 BindingKey 可以看成是同一个东西，因为他们要匹配才能路由。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 创建一个 type=direct 持久化、非自动删除的交换器</span>
channel<span class="token punctuation">.</span><span class="token function">exchangeDeclare</span><span class="token punctuation">(</span>EXCHANGE_NAME<span class="token punctuation">,</span> <span class="token string">&quot;direct&quot;</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 创建一个：持久化、非排他的、非自动删除的队列</span>
channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>QUEUE_NAME<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 将交换器与队列通过 路由键 绑定</span>
channel<span class="token punctuation">.</span><span class="token function">queueBind</span><span class="token punctuation">(</span>QUEUE_NAME<span class="token punctuation">,</span> EXCHANGE_NAME<span class="token punctuation">,</span> ROUTING_KEY<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">&quot;Hello World!&quot;</span><span class="token punctuation">;</span>
channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span>EXCHANGE_NAME<span class="token punctuation">,</span>
                     ROUTING_KEY<span class="token punctuation">,</span>
                     <span class="token class-name">MessageProperties</span><span class="token punctuation">.</span>PERSISTENT_TEXT_PLAIN<span class="token punctuation">,</span>
                     message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>如上部分代码，声明了一个 direct 类型的交换交换器，将队列绑定到交换机使用的是 ROUTING_KEY，这里本应该使用 BindingKey， <code>channel.basicPublis</code> 中发送消息也使用了 ROUTING_KEY，这说明在 direct 类型的交换器中他们是同一个东西。</p> <p>但是在 topic 交换器类型下，ROUTING_KEY 和 BindingKey 之间需要做模糊匹配，他们就不是相同的了；</p> <p>为了避免混淆，可以如下理解：</p> <ul><li><p>在使用绑定的时候，需要的是 BindingKey</p> <p>对应的 API 是 <code>channel.exchangeBind</code> 、<code>channel.queueBind</code></p> <p>对应的 AMQP 命令是 <code>Exchange.Bind</code> 、<code>Queue.Bind</code></p></li> <li><p>在发送消息时，使用的是 ROUTING_KEY</p> <p>对应的 API 是：<code>channel.basicPublish</code></p> <p>对应的 AMQP 命令是：<code>Basic.Publish</code></p></li></ul> <h2 id="交换器类型"><a href="#交换器类型" class="header-anchor">#</a> 交换器类型</h2> <p>RabbitMQ 常用的交换器类型有：</p> <ul><li>fanout：相当于广播消息，广播到绑定到交换器的队列</li> <li>direct：路由到 RoutingKey 与 BindingKey 相同的队列</li> <li>topic</li> <li>headers</li></ul> <p>AMQP 协议里还有两种类型：System 和 自定义。这里只讲解以上 4 种类型。</p> <h3 id="fanout"><a href="#fanout" class="header-anchor">#</a> fanout</h3> <p>把所有发送到该交换器的消息路由到所有与交换器绑定的队列中。<strong>相当于广播消息</strong></p> <h3 id="direct"><a href="#direct" class="header-anchor">#</a> direct</h3> <p>把消息 <strong>路由到 BindingKey 和 RoutingKey 完全匹配的队列中</strong>。</p> <p><img src="/mq-tutorial/assets/img/image-20200623143852813.423454fd.png" alt="image-20200623143852813"></p> <p>Queue 2  绑定了 3 个 BindingKey，当消息指定的 RoutingKey 为 warming 时，两个队列都能收到，为 info 时，就只有 Queue 2 能收到。</p> <h3 id="topic"><a href="#topic" class="header-anchor">#</a> topic</h3> <p>与 direct 类型的交换器相似，也是将消息路由到 RoutingKey 与 BindingKey 相匹配的队列中，但是这里的匹配规则不同，它约定：</p> <ul><li><p>RoutingKey 为一个点号「<code>.</code>」分隔的字符串</p> <p>被「<code>.</code>」 分隔开的每一段独立的字符串成为一个单词。如 <code>com.rabbitmq.client</code></p></li> <li><p>BindingKey 和 RoutingKey 一样也是一个点号「<code>.</code>」分隔的字符串</p></li> <li><p>BindingKey 中可以存在两种特殊字符串，用作模糊匹配</p> <ul><li><p><code>#</code>：用于匹配一个单词</p></li> <li><p><code>*</code>：用于匹配多规格的单词，可以是零个</p></li></ul></li></ul> <p><img src="/mq-tutorial/assets/img/image-20200623145055359.1a5dd792.png" alt="image-20200623145055359"></p> <p>对于以上设置绑定关系，如下的路由键路由方向为：</p> <ul><li><code>com.rabbitmq.client</code>：同时路由到 Q1 和 Q2</li> <li><code>com.hidden.client</code>：只路由到 Q2</li> <li><code>com.hidden.demo</code>：只路由到 Q2，因为匹配了 ``com.hidden`</li> <li><code>java.rabbitmq.demo</code>：只会路由到 Q1</li> <li><code>java.util.concurrent</code>：没有匹配任何路由键，可能被丢弃或返回给生产者（需要设置 mandatory 参数）</li></ul> <h3 id="headers"><a href="#headers" class="header-anchor">#</a> headers</h3> <p>headers 类型的交换器 <strong>不依赖于路由键的匹配规则来路由消息</strong>，根据发送的消息内容中的 <strong>headers 属性进行匹配</strong>。</p> <p>在绑定队列和交换器时制定一组键值对，发送消息到交换器时，会获取该消息的 headers ，对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，完全匹配则路由到该队列。</p> <p>headers 类型的交换器性能会很差，不推荐使用。</p> <h2 id="rabbitmq-的运转流程"><a href="#rabbitmq-的运转流程" class="header-anchor">#</a> RabbitMQ 的运转流程</h2> <p>回顾下整个消息队列的使用过程，在最初状态下，生产者发送消息时：</p> <ol><li><p>连接到 RabbitMQ Broker，建立一个连接 Connection，开启一个信道 Channel</p></li> <li><p>声明一个交换器，并设置相关属性</p> <p>比如：交换器类型、是否持久化等</p></li> <li><p>声明一个队列，并设置相关属性</p> <p>比如：是否排他、是否持久化、是否自动删除等</p></li> <li><p>通过路由键将交换器和队列绑定起来</p></li> <li><p>发送消息到 Broker</p> <p>其中包含：路由键、交换器等信息</p></li> <li><p>相应交换器根据接收到的路由键查找匹配的队列</p></li> <li><p>如果找到：则存入相应的队列中。</p></li> <li><p>如果没有找到：则根据生产者配置的属性，选择丢弃还是回退给生产者</p></li> <li><p>关闭信道和链接</p></li></ol> <p>消费者接收消息的过程：</p> <ol><li>链接到 RabbitMQ Broker，建立一个链接 Connection，开启一个信道 Channel</li> <li>向 Broker 请求消费相应队列中的消息，可能会设置相应的回调函数，以及做一些准备工作</li> <li>等待 Broker 回应并投递相依队列中的消息，消费者接收消息</li> <li>消费者确认（ack）接收消息</li> <li>RabbitMQ 从队列中删除相应以及被确认的消息</li> <li>关闭信道和链接</li></ol> <p><img src="/mq-tutorial/assets/img/image-20200623152555013.799ba521.png" alt="image-20200623152555013"></p> <p>无论生产者与消费者都要与 Broker 建立连接，该链接就是一条 TCP 链接（Connection）。客户端可以创建一个 AMQP 信道（Channel），<strong>每个信道会被指派一个唯一的 ID</strong>。</p> <p><strong>信道是建立在 Connection 之上的虚拟连接</strong>，RabbitMQ 处理的每条 AMQP 指令都是通过信道完成的。这个模式是类似 NIO（Non-blocking I/O）的做法，TCP 链接复用，减少性能开销，同时也便于管理。</p> <div class="custom-block tip"><p class="custom-block-title">NIO</p> <p>NIO 也称非阻塞 I/O，包含三大核心部分：Channel 信道、Buffer 缓冲区、Selector 选择器。</p> <p>NIO 基于 Channel 和 Buffer 进行操作，数据总是从信道读取到缓冲区中，或则从缓冲区写入到信道中。</p> <p>Selector 用于监听多个信道的事件（如：打开链接、数据到达等）。因此，单线程可以监听多个数据的信道。</p> <p>NIO 中有一个很有名的 <a href="https://zq99299.github.io/note-book/mycat/frontend_connection_interaction.html#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86" target="_blank" rel="noopener noreferrer">Reactor 模式<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p></div> <p>所以你的程序具体需要几个 Connection ，这个需要根据你业务量来进行调节，当一个 Connection 上的信道太多时，可能会产生瓶颈，就需要考虑使用多个 Connection 了。</p> <p>信道在 AMQP 中是一个很重要的概念，大多数操作都在信道这个层面展开的。在前面的代码演示中，也可以看到，很多操作都是在 Channel 对象上完成的。</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/zq99299/mq-tutorial/edit/master/docs/rabbitmq-ac/02/01.md" target="_blank" rel="noopener noreferrer">帮助我们改善此页面！</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">上次更新: :</span> <span class="time">10 days ago</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/mq-tutorial/rabbitmq-ac/" class="prev router-link-active">
        RabbitMq 实战指南
      </a></span> <span class="next"><a href="/mq-tutorial/rabbitmq-ac/02/02.html">
        AQMP 协议介绍
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/mq-tutorial/assets/js/app.fccc8b77.js" defer></script><script src="/mq-tutorial/assets/js/2.69dbb0e8.js" defer></script><script src="/mq-tutorial/assets/js/3.6c91dad7.js" defer></script><script src="/mq-tutorial/assets/js/5.8981dd5c.js" defer></script>
  </body>
</html>
