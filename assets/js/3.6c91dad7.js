(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{366:function(t,a,s){t.exports=s.p+"assets/img/image-20200623134112047.9b0e71cd.png"},367:function(t,a,s){t.exports=s.p+"assets/img/image-20200623135211410.bc805667.png"},368:function(t,a,s){t.exports=s.p+"assets/img/image-20200623140440544.b52ae18f.png"},369:function(t,a,s){t.exports=s.p+"assets/img/image-20200623141205312.ae38e6ea.png"},370:function(t,a,s){t.exports=s.p+"assets/img/image-20200623141825523.36e0d71d.png"},371:function(t,a,s){t.exports=s.p+"assets/img/image-20200623143852813.423454fd.png"},372:function(t,a,s){t.exports=s.p+"assets/img/image-20200623145055359.1a5dd792.png"},373:function(t,a,s){t.exports=s.p+"assets/img/image-20200623152555013.799ba521.png"},429:function(t,a,s){"use strict";s.r(a);var n=s(20),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"相关概念介绍"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#相关概念介绍"}},[t._v("#")]),t._v(" 相关概念介绍")]),t._v(" "),n("p",[t._v("RabbitMQ 整体上是一个 "),n("strong",[t._v("生产者与消费者模型")]),t._v("，主要负责 "),n("strong",[t._v("接收、存储和转发消息")]),t._v("。")]),t._v(" "),n("p",[n("img",{attrs:{src:s(366),alt:"image-20200623134112047"}})]),t._v(" "),n("h2",{attrs:{id:"生产者和消费者"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#生产者和消费者"}},[t._v("#")]),t._v(" 生产者和消费者")]),t._v(" "),n("h3",{attrs:{id:"生产者"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#生产者"}},[t._v("#")]),t._v(" 生产者")]),t._v(" "),n("p",[t._v("Producer：生产者，投递消息的一方")]),t._v(" "),n("p",[t._v("生产者创建消息，发布到 RabbitMQ 中。")]),t._v(" "),n("p",[t._v("消息一般可以包含 2 个部分：")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("消息体（payload）")]),t._v(" "),n("p",[t._v("你的业务数据，比如一个 JSON 字符串")])]),t._v(" "),n("li",[n("p",[t._v("标签（label）：用来描述这条消息")]),t._v(" "),n("p",[t._v("比如：一个交换器的名称和一个路由键。RabbitMQ 会根据标签把消息发送给感兴趣的消费者（Consumer）")])])]),t._v(" "),n("h3",{attrs:{id:"消费者"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#消费者"}},[t._v("#")]),t._v(" 消费者")]),t._v(" "),n("p",[t._v("Consumer：消费者，接收消息的一方")]),t._v(" "),n("p",[t._v("消费者链接到 RabbitMQ，并 "),n("strong",[t._v("订阅到队列")]),t._v(" 上。当消费者消费一条消息时，只是消费消息的 "),n("strong",[t._v("消息体（payload）")]),t._v("，路由过程中，"),n("strong",[t._v("消息的标签会丢弃")]),t._v("，"),n("strong",[t._v("存入到队列中的消息只有消息体")]),t._v("。")]),t._v(" "),n("p",[t._v("消费者不知道生产者是谁。")]),t._v(" "),n("h3",{attrs:{id:"broker"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#broker"}},[t._v("#")]),t._v(" Broker")]),t._v(" "),n("p",[t._v("Broker：消息中间件的服务节点。")]),t._v(" "),n("p",[t._v("对于 RabbitMQ 来说，一个 Broker 可以简单看成一个 RabbitMQ 服务节点，或则 RabbitMQ 服务实例。")]),t._v(" "),n("p",[t._v("下图展示了：生产者将消息存入 Broker，以及消费者从 Broker 中消费数据的整个流程")]),t._v(" "),n("p",[n("img",{attrs:{src:s(367),alt:"image-20200623135211410"}})]),t._v(" "),n("ul",[n("li",[n("p",[t._v("生产者将消息发送到 Broker 中")]),t._v(" "),n("p",[t._v("发送：对应的 AMQP 协议命令为  "),n("code",[t._v("Basic.Publish")])])]),t._v(" "),n("li",[n("p",[t._v("消费者订阅并接收消息")]),t._v(" "),n("p",[t._v("订阅并接收：对应的 AMQP 协议命令为 "),n("code",[t._v("Basic.Consume")]),t._v(" 或 "),n("code",[t._v("Basic.Get")])])])]),t._v(" "),n("h2",{attrs:{id:"队列"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#队列"}},[t._v("#")]),t._v(" 队列")]),t._v(" "),n("p",[t._v("Queue：队列 ，是 RabbitMQ 的内部对象，用于存储消息。")]),t._v(" "),n("p",[t._v("RabbitMQ 中消息都 "),n("strong",[t._v("只能存储在队列中")]),t._v("，kafka 将消息存储在 topic 这个逻辑层面中，而相对应的队列逻辑知识 topic 实际存储文件中的位置偏移标识。")]),t._v(" "),n("p",[n("strong",[t._v("多个消费者可以订阅同一个队列")]),t._v("，这时队列中的消息会被 "),n("strong",[t._v("平均分摊")]),t._v("（Round-Robin 轮询）给多个消费者进行处理。")]),t._v(" "),n("p",[n("img",{attrs:{src:s(368),alt:"image-20200623140440544"}})]),t._v(" "),n("p",[t._v("RabbitMQ "),n("strong",[t._v("不支持队列层面的广播消息")]),t._v("，如果需要广播消费，需要进行二次开发，麻烦，不推荐。")]),t._v(" "),n("h2",{attrs:{id:"交换器、路由键、绑定"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#交换器、路由键、绑定"}},[t._v("#")]),t._v(" 交换器、路由键、绑定")]),t._v(" "),n("h3",{attrs:{id:"exchange-交换器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#exchange-交换器"}},[t._v("#")]),t._v(" Exchange 交换器")]),t._v(" "),n("p",[t._v("在图 2-4 中，消息并不是直接到队列中的，而是消息先到 Exchange（交换器，通常用大写的 X 表示），"),n("strong",[t._v("由交换器将消息路由到一个或多个队列中")]),t._v("。如果路由不到，或许会返回给生产者，或许会直接丢弃。")]),t._v(" "),n("p",[t._v("示意图如下")]),t._v(" "),n("p",[n("img",{attrs:{src:s(369),alt:"image-20200623141205312"}})]),t._v(" "),n("p",[t._v("RabbitMQ 中的交换器有 4 种类型，不同的类型有不同的策略，后续详细讲解。")]),t._v(" "),n("h3",{attrs:{id:"routingkey-路由键"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#routingkey-路由键"}},[t._v("#")]),t._v(" RoutingKey 路由键")]),t._v(" "),n("p",[t._v("生产者将消息发给交换器时，一般会指定一个 RoutingKey，用来指定这个消息的路由规则。")]),t._v(" "),n("p",[t._v("RoutingKey 需要与"),n("strong",[t._v("交换器类型")]),t._v("和 "),n("strong",[t._v("绑定键（BindingKey）")]),t._v(" 联合使用才能最终生效")]),t._v(" "),n("h3",{attrs:{id:"binding-绑定"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#binding-绑定"}},[t._v("#")]),t._v(" Binding 绑定")]),t._v(" "),n("p",[t._v("通过 "),n("strong",[t._v("绑定")]),t._v(" 将 "),n("strong",[t._v("交换器与队列关联")]),t._v(" 起来，绑定时一般会指定一个 "),n("strong",[t._v("绑定键（BindingKey）")]),t._v("，这样 RabbitMQ 就知道如何正确将消息路由到队列了，示意图如下：")]),t._v(" "),n("p",[n("img",{attrs:{src:s(370),alt:"image-20200623141825523"}})]),t._v(" "),n("p",[t._v("生产者将消息发送给交换器时，需要一个 RoutingKey，"),n("strong",[t._v("当 BindingKey 和 RoutingKey 匹配时")]),t._v("，消息被路由到对应的队列中。")]),t._v(" "),n("p",[t._v("绑定多个队列到同一个交换器时，BindingKey 允许相同。BindingKey 只能在 "),n("strong",[t._v("指定的交换器类型下生效")]),t._v("，比如 fanout 类型的交换器就不生效，它将消息路由到所有绑定到该交换器的队列中。")]),t._v(" "),n("p",[t._v("其实你已经发现了：在某些情况下，RoutingKey 与 BindingKey 可以看成是同一个东西，因为他们要匹配才能路由。")]),t._v(" "),n("div",{staticClass:"language-java line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 创建一个 type=direct 持久化、非自动删除的交换器")]),t._v("\nchannel"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("exchangeDeclare")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("EXCHANGE_NAME"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"direct"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 创建一个：持久化、非排他的、非自动删除的队列")]),t._v("\nchannel"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("queueDeclare")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("QUEUE_NAME"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将交换器与队列通过 路由键 绑定")]),t._v("\nchannel"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("queueBind")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("QUEUE_NAME"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" EXCHANGE_NAME"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" ROUTING_KEY"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" message "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Hello World!"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nchannel"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("basicPublish")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("EXCHANGE_NAME"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                     ROUTING_KEY"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                     "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MessageProperties")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("PERSISTENT_TEXT_PLAIN"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                     message"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("getBytes")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br"),n("span",{staticClass:"line-number"},[t._v("5")]),n("br"),n("span",{staticClass:"line-number"},[t._v("6")]),n("br"),n("span",{staticClass:"line-number"},[t._v("7")]),n("br"),n("span",{staticClass:"line-number"},[t._v("8")]),n("br"),n("span",{staticClass:"line-number"},[t._v("9")]),n("br"),n("span",{staticClass:"line-number"},[t._v("10")]),n("br"),n("span",{staticClass:"line-number"},[t._v("11")]),n("br"),n("span",{staticClass:"line-number"},[t._v("12")]),n("br")])]),n("p",[t._v("如上部分代码，声明了一个 direct 类型的交换交换器，将队列绑定到交换机使用的是 ROUTING_KEY，这里本应该使用 BindingKey， "),n("code",[t._v("channel.basicPublis")]),t._v(" 中发送消息也使用了 ROUTING_KEY，这说明在 direct 类型的交换器中他们是同一个东西。")]),t._v(" "),n("p",[t._v("但是在 topic 交换器类型下，ROUTING_KEY 和 BindingKey 之间需要做模糊匹配，他们就不是相同的了；")]),t._v(" "),n("p",[t._v("为了避免混淆，可以如下理解：")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("在使用绑定的时候，需要的是 BindingKey")]),t._v(" "),n("p",[t._v("对应的 API 是 "),n("code",[t._v("channel.exchangeBind")]),t._v(" 、"),n("code",[t._v("channel.queueBind")])]),t._v(" "),n("p",[t._v("对应的 AMQP 命令是 "),n("code",[t._v("Exchange.Bind")]),t._v(" 、"),n("code",[t._v("Queue.Bind")])])]),t._v(" "),n("li",[n("p",[t._v("在发送消息时，使用的是 ROUTING_KEY")]),t._v(" "),n("p",[t._v("对应的 API 是："),n("code",[t._v("channel.basicPublish")])]),t._v(" "),n("p",[t._v("对应的 AMQP 命令是："),n("code",[t._v("Basic.Publish")])])])]),t._v(" "),n("h2",{attrs:{id:"交换器类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#交换器类型"}},[t._v("#")]),t._v(" 交换器类型")]),t._v(" "),n("p",[t._v("RabbitMQ 常用的交换器类型有：")]),t._v(" "),n("ul",[n("li",[t._v("fanout：相当于广播消息，广播到绑定到交换器的队列")]),t._v(" "),n("li",[t._v("direct：路由到 RoutingKey 与 BindingKey 相同的队列")]),t._v(" "),n("li",[t._v("topic")]),t._v(" "),n("li",[t._v("headers")])]),t._v(" "),n("p",[t._v("AMQP 协议里还有两种类型：System 和 自定义。这里只讲解以上 4 种类型。")]),t._v(" "),n("h3",{attrs:{id:"fanout"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#fanout"}},[t._v("#")]),t._v(" fanout")]),t._v(" "),n("p",[t._v("把所有发送到该交换器的消息路由到所有与交换器绑定的队列中。"),n("strong",[t._v("相当于广播消息")])]),t._v(" "),n("h3",{attrs:{id:"direct"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#direct"}},[t._v("#")]),t._v(" direct")]),t._v(" "),n("p",[t._v("把消息 "),n("strong",[t._v("路由到 BindingKey 和 RoutingKey 完全匹配的队列中")]),t._v("。")]),t._v(" "),n("p",[n("img",{attrs:{src:s(371),alt:"image-20200623143852813"}})]),t._v(" "),n("p",[t._v("Queue 2  绑定了 3 个 BindingKey，当消息指定的 RoutingKey 为 warming 时，两个队列都能收到，为 info 时，就只有 Queue 2 能收到。")]),t._v(" "),n("h3",{attrs:{id:"topic"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#topic"}},[t._v("#")]),t._v(" topic")]),t._v(" "),n("p",[t._v("与 direct 类型的交换器相似，也是将消息路由到 RoutingKey 与 BindingKey 相匹配的队列中，但是这里的匹配规则不同，它约定：")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("RoutingKey 为一个点号「"),n("code",[t._v(".")]),t._v("」分隔的字符串")]),t._v(" "),n("p",[t._v("被「"),n("code",[t._v(".")]),t._v("」 分隔开的每一段独立的字符串成为一个单词。如 "),n("code",[t._v("com.rabbitmq.client")])])]),t._v(" "),n("li",[n("p",[t._v("BindingKey 和 RoutingKey 一样也是一个点号「"),n("code",[t._v(".")]),t._v("」分隔的字符串")])]),t._v(" "),n("li",[n("p",[t._v("BindingKey 中可以存在两种特殊字符串，用作模糊匹配")]),t._v(" "),n("ul",[n("li",[n("p",[n("code",[t._v("#")]),t._v("：用于匹配一个单词")])]),t._v(" "),n("li",[n("p",[n("code",[t._v("*")]),t._v("：用于匹配多规格的单词，可以是零个")])])])])]),t._v(" "),n("p",[n("img",{attrs:{src:s(372),alt:"image-20200623145055359"}})]),t._v(" "),n("p",[t._v("对于以上设置绑定关系，如下的路由键路由方向为：")]),t._v(" "),n("ul",[n("li",[n("code",[t._v("com.rabbitmq.client")]),t._v("：同时路由到 Q1 和 Q2")]),t._v(" "),n("li",[n("code",[t._v("com.hidden.client")]),t._v("：只路由到 Q2")]),t._v(" "),n("li",[n("code",[t._v("com.hidden.demo")]),t._v("：只路由到 Q2，因为匹配了 ``com.hidden`")]),t._v(" "),n("li",[n("code",[t._v("java.rabbitmq.demo")]),t._v("：只会路由到 Q1")]),t._v(" "),n("li",[n("code",[t._v("java.util.concurrent")]),t._v("：没有匹配任何路由键，可能被丢弃或返回给生产者（需要设置 mandatory 参数）")])]),t._v(" "),n("h3",{attrs:{id:"headers"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#headers"}},[t._v("#")]),t._v(" headers")]),t._v(" "),n("p",[t._v("headers 类型的交换器 "),n("strong",[t._v("不依赖于路由键的匹配规则来路由消息")]),t._v("，根据发送的消息内容中的 "),n("strong",[t._v("headers 属性进行匹配")]),t._v("。")]),t._v(" "),n("p",[t._v("在绑定队列和交换器时制定一组键值对，发送消息到交换器时，会获取该消息的 headers ，对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，完全匹配则路由到该队列。")]),t._v(" "),n("p",[t._v("headers 类型的交换器性能会很差，不推荐使用。")]),t._v(" "),n("h2",{attrs:{id:"rabbitmq-的运转流程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq-的运转流程"}},[t._v("#")]),t._v(" RabbitMQ 的运转流程")]),t._v(" "),n("p",[t._v("回顾下整个消息队列的使用过程，在最初状态下，生产者发送消息时：")]),t._v(" "),n("ol",[n("li",[n("p",[t._v("连接到 RabbitMQ Broker，建立一个连接 Connection，开启一个信道 Channel")])]),t._v(" "),n("li",[n("p",[t._v("声明一个交换器，并设置相关属性")]),t._v(" "),n("p",[t._v("比如：交换器类型、是否持久化等")])]),t._v(" "),n("li",[n("p",[t._v("声明一个队列，并设置相关属性")]),t._v(" "),n("p",[t._v("比如：是否排他、是否持久化、是否自动删除等")])]),t._v(" "),n("li",[n("p",[t._v("通过路由键将交换器和队列绑定起来")])]),t._v(" "),n("li",[n("p",[t._v("发送消息到 Broker")]),t._v(" "),n("p",[t._v("其中包含：路由键、交换器等信息")])]),t._v(" "),n("li",[n("p",[t._v("相应交换器根据接收到的路由键查找匹配的队列")])]),t._v(" "),n("li",[n("p",[t._v("如果找到：则存入相应的队列中。")])]),t._v(" "),n("li",[n("p",[t._v("如果没有找到：则根据生产者配置的属性，选择丢弃还是回退给生产者")])]),t._v(" "),n("li",[n("p",[t._v("关闭信道和链接")])])]),t._v(" "),n("p",[t._v("消费者接收消息的过程：")]),t._v(" "),n("ol",[n("li",[t._v("链接到 RabbitMQ Broker，建立一个链接 Connection，开启一个信道 Channel")]),t._v(" "),n("li",[t._v("向 Broker 请求消费相应队列中的消息，可能会设置相应的回调函数，以及做一些准备工作")]),t._v(" "),n("li",[t._v("等待 Broker 回应并投递相依队列中的消息，消费者接收消息")]),t._v(" "),n("li",[t._v("消费者确认（ack）接收消息")]),t._v(" "),n("li",[t._v("RabbitMQ 从队列中删除相应以及被确认的消息")]),t._v(" "),n("li",[t._v("关闭信道和链接")])]),t._v(" "),n("p",[n("img",{attrs:{src:s(373),alt:"image-20200623152555013"}})]),t._v(" "),n("p",[t._v("无论生产者与消费者都要与 Broker 建立连接，该链接就是一条 TCP 链接（Connection）。客户端可以创建一个 AMQP 信道（Channel），"),n("strong",[t._v("每个信道会被指派一个唯一的 ID")]),t._v("。")]),t._v(" "),n("p",[n("strong",[t._v("信道是建立在 Connection 之上的虚拟连接")]),t._v("，RabbitMQ 处理的每条 AMQP 指令都是通过信道完成的。这个模式是类似 NIO（Non-blocking I/O）的做法，TCP 链接复用，减少性能开销，同时也便于管理。")]),t._v(" "),n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[t._v("NIO")]),t._v(" "),n("p",[t._v("NIO 也称非阻塞 I/O，包含三大核心部分：Channel 信道、Buffer 缓冲区、Selector 选择器。")]),t._v(" "),n("p",[t._v("NIO 基于 Channel 和 Buffer 进行操作，数据总是从信道读取到缓冲区中，或则从缓冲区写入到信道中。")]),t._v(" "),n("p",[t._v("Selector 用于监听多个信道的事件（如：打开链接、数据到达等）。因此，单线程可以监听多个数据的信道。")]),t._v(" "),n("p",[t._v("NIO 中有一个很有名的 "),n("a",{attrs:{href:"https://zq99299.github.io/note-book/mycat/frontend_connection_interaction.html#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86",target:"_blank",rel:"noopener noreferrer"}},[t._v("Reactor 模式"),n("OutboundLink")],1),t._v("。")])]),t._v(" "),n("p",[t._v("所以你的程序具体需要几个 Connection ，这个需要根据你业务量来进行调节，当一个 Connection 上的信道太多时，可能会产生瓶颈，就需要考虑使用多个 Connection 了。")]),t._v(" "),n("p",[t._v("信道在 AMQP 中是一个很重要的概念，大多数操作都在信道这个层面展开的。在前面的代码演示中，也可以看到，很多操作都是在 Channel 对象上完成的。")])])}),[],!1,null,null,null);a.default=e.exports}}]);