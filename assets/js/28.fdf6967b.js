(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{411:function(t,n,s){"use strict";s.r(n);var a=s(20),e=Object(a.a)({},(function(){var t=this,n=t.$createElement,s=t._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"消费端要点介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消费端要点介绍"}},[t._v("#")]),t._v(" 消费端要点介绍")]),t._v(" "),s("p",[t._v("消费者客户端可以通过 "),s("strong",[t._v("推模式")]),t._v(" 和 "),s("strong",[t._v("拉模式")]),t._v(" 来获取并消费消息，RabbitMQ 把消息推送后（或客户端主动 ACK）后，RabbitMQ 把当前消息从队列中标记清除。如果由于某些原因无法处理当前接受到的信息，可以通过 "),s("code",[t._v("channel.basicNack")]),t._v(" 或则 "),s("code",[t._v("channel.basicReject")]),t._v(" 来拒绝掉。")]),t._v(" "),s("p",[t._v("对于消费者来说，还有几点需要注意：")]),t._v(" "),s("ul",[s("li",[t._v("消息分发")]),t._v(" "),s("li",[t._v("消息顺序性")]),t._v(" "),s("li",[t._v("弃用 QueueingConsumer")])]),t._v(" "),s("h2",{attrs:{id:"消息分发"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消息分发"}},[t._v("#")]),t._v(" 消息分发")]),t._v(" "),s("p",[t._v("当 RabbitMQ "),s("strong",[t._v("队列有多个消费者")]),t._v(" 时，队列收到的消息将以 "),s("strong",[t._v("轮询（round-robin）")]),t._v(" 方式分发给消费者，每条消息只会发送给订阅列表里的 "),s("strong",[t._v("一个消费者")]),t._v("。这种方式是专门为并发程序设计的，如果程序处理不过来，只要增加更多的消费者来处理消息即可。")]),t._v(" "),s("p",[t._v("很多时候轮询的分发机制也有问题。默认情况下，如果有 n 个消费者，RabbitMQ 会将第 m 条消息分发给第 "),s("code",[t._v("m%n")]),t._v(" (取余) 个消费者。RabbitMQ "),s("strong",[t._v("不管消费者是否消费并已经确认")]),t._v("（Basic.Ack）消息。就可能会导致：某些消费者来不及处理消息，有些处理得很快的情况。")]),t._v(" "),s("p",[t._v("这种情况，需要 "),s("strong",[t._v("限制信道上")]),t._v(" 的消费者所能 "),s("strong",[t._v("保持的最大未确认消息的数量")]),t._v("，通过 "),s("code",[t._v("channel.basicQos(int prefetchCount)")]),t._v(" 方法。")]),t._v(" "),s("p",[t._v("举例说明：在订阅队列之前，消费者设置 "),s("code",[t._v("channel.basicQos(5)")]),t._v("，再订阅队列。 RabbitMQ 会保存一个消费者的列表，每发送一条消息都会为对应的消费者计数，如果到达了设置上限，就不会向这个消费者再发送任何消息。直到消费者确认了某条消费者之后，RabbitMQ 把对应的计数器 -1，继续分发消息。")]),t._v(" "),s("p",[t._v("注意要点："),s("code",[t._v("Basic.Qos")]),t._v(" 对拉模式无效")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("basicQos")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" prefetchSize"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" prefetchCount"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" global"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("throws")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("IOException")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("ul",[s("li",[s("p",[t._v("prefetchSize：消费者所能接受未确认消息的总体大小的上限（单位为 B），设置为 0 时，表示无上限")])]),t._v(" "),s("li",[s("p",[t._v("prefetchCount：消费者所能接受最大未确认消息的数量")])]),t._v(" "),s("li",[s("p",[t._v("global：")]),t._v(" "),s("p",[t._v("一个信道可以消费多个队列")]),t._v(" "),s("p",[t._v("当该值大于 0 时，这个信道需要和各个队列协调，确保发送的消息都没有超过所限定的  prefetchCount。这会让 RabbitMQ 的性能降低，尤其当这些队列分散在集群中的多个 Broker 节点之中。为了解决这个性能问题，定义了 global 参数")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",{staticStyle:{"text-align":"center"}},[t._v("global  参数")]),t._v(" "),s("th",[t._v("AMQP 0-9-1")]),t._v(" "),s("th",[t._v("RabbitMQ")])])]),t._v(" "),s("tbody",[s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("false")]),t._v(" "),s("td",[t._v("信道上所有的消费者都要遵从 prefetchCount 的限制")]),t._v(" "),s("td",[t._v("信道上所有的消费者都要遵从 prefetchCount 的限制")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("true")]),t._v(" "),s("td",[t._v("当前通信链路（Connection）上所有的消费者需要遵循从 prefetchCount 的限制")]),t._v(" "),s("td",[t._v("信道上所有的消费者都要遵从 prefetchCount 的限制（这里不知道书上是不是写错了？）")])])])]),t._v(" "),s("p",[t._v("channel.basicQos 只针对单个消费者的。对于同一个信道上的多个消费者而言，如果设置了 prefetchCount ，则都会生效。")]),t._v(" "),s("p",[t._v("如下代码，各自的能接收到的未确认消息上限都是 10")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("channel"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("basicQos")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nchannel"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("basicConsume")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"queue1"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("consumerl1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nchannel"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("basicConsume")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"queue2"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("consumerl2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("如果同时设置了 global 为 false 和 true 呢？他们两个的限制都有效果：如下面这段代码")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("channel"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("basicQos")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nchannel"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("basicQos")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nchannel"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("basicConsume")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"queue1"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" consumerl1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nchannel"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("basicConsume")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"queue2"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" consumerl2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("p",[t._v("那么生效情况如下：")]),t._v(" "),s("ul",[s("li",[t._v("每个消费者最多可收到  3 个未确认的消息")]),t._v(" "),s("li",[t._v("两个消费者最多可收到 5 个未确认的消息")])]),t._v(" "),s("p",[t._v("这种设置方式，会增加 RabbitMQ 的负载，会使用更多的资源来协调完成这些限制。建议用默认值的 false。")])])]),t._v(" "),s("h2",{attrs:{id:"消息顺序性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消息顺序性"}},[t._v("#")]),t._v(" 消息顺序性")]),t._v(" "),s("p",[t._v("指：消费者消 "),s("strong",[t._v("费到的消息")]),t._v(" 和发送者 "),s("strong",[t._v("发布的消息")]),t._v(" 顺序是一致的。")]),t._v(" "),s("p",[t._v("如：发布 "),s("code",[t._v("1,2,3")]),t._v(" 那么消费的顺序也是 "),s("code",[t._v("1,2,3")])]),t._v(" "),s("p",[t._v("在 "),s("strong",[t._v("单个生产者和单个消费者的情况下，消息的有序性是能保证的")]),t._v("，也是可验证的。在多消费者和多生产者的情况下，无法确定消息到达 Broker 的前后顺序，也无法确定客户端消费的顺序，这个其实是正常现象。分布式中本来就存在这样的现象。")]),t._v(" "),s("p",[t._v("有如下几种情况，消息的顺序性会被打破：但都是正常现象：")]),t._v(" "),s("ul",[s("li",[t._v("使用事物机制时，发送失败，使用另一个线程补发此消息。此时消息就不能保证按照 "),s("code",[t._v("1,2,3,4")]),t._v(" 的顺序到达 Broker 了")]),t._v(" "),s("li",[t._v("使用不同的消息过期时间，先过期的先被消费")]),t._v(" "),s("li",[t._v("使用优先级消息，优先级高的先被消费")]),t._v(" "),s("li",[t._v("客户端使用 "),s("code",[t._v("Basic.Nack/.Reject")]),t._v(" 将消息拒绝时，同时 requeue= true， 消息重入队列后，也无法保证消息顺序还和发送的时候是一致的")])]),t._v(" "),s("p",[t._v("从以上点可以看到，在很多场景下，并不能保证消息的顺序性。")]),t._v(" "),s("p",[t._v("如果想要实现消息的有序性，则可以通过在消息体内增加全部有序标识，程序端自己实现逻辑判定")]),t._v(" "),s("h2",{attrs:{id:"启用-queuingconsumer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#启用-queuingconsumer"}},[t._v("#")]),t._v(" 启用 QueuingConsumer")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v('   ...\n    queueingConsumer = new QueueingConsumer(channel);\n    channel.basicConsume(replyQueue, true, queueingConsumer);\n}\n\npublic String call(String message) throws IOException, InterruptedException {\n    final String corrid = UUID.randomUUID().toString();\n    final AMQP.BasicProperties properties = new AMQP.BasicProperties()\n            .builder()\n            .correlationId(corrid)\n            .replyTo(replyQueue)\n            .build();\n    channel.basicPublish("", requestQueue, properties, "message".getBytes());\n\n    // 想服务端发送后，轮询，知道回去到服务端的响应为止\n    while (true) {\n        final QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery();\n        if (delivery.getProperties().getCorrelationId().equals(corrid)) {\n            return new String(delivery.getBody());\n        }\n    }\n}\n')])])]),s("p",[t._v("前面讲解 "),s("RouterLink",{attrs:{to:"/rabbitmq-ac/04/06.html"}},[t._v("RPC 实现")]),t._v(" 中用到过这个类，如上的代码片段。在 RabbitMQ 4.x 中被标记为 "),s("code",[t._v("@Deprecated")]),t._v(" 了。")],1),t._v(" "),s("p",[t._v("是因为该类有几个大缺陷：比如内存溢出问题，由于某些原因，队列中堆积了比较多的消息，可能导致消费者客户端内存溢出假死，于是发生恶性循环，队列消息不断堆积而得不到消费。")]),t._v(" "),s("p",[t._v("导致内存溢出的原因是：QueuingConsumer 内部使用 LinkedBlockingQueue 来缓存消息，当设置的 "),s("code",[t._v("Basic.Qos")]),t._v(" 数量太大的时候，消息体也很大（如一个消息 200M），那么就会导致内存溢出。可通过限制 qos 的数量来解决这个问题，但是一定 "),s("strong",[t._v("要在订阅之前设置")])]),t._v(" "),s("p",[t._v("QueuingConsumer 还包括以下缺陷（包括但不限于）：")]),t._v(" "),s("ul",[s("li",[t._v("会拖累同一个 Connection 下的所有通道，使其性能降低")]),t._v(" "),s("li",[t._v("同步递归调用 QueuingConsumer 会产生死锁")]),t._v(" "),s("li",[t._v("RabbitMQ 的自动连接恢复机制（automatic Connection recovery） 不支持 QueuingConsumer 的这种形式")]),t._v(" "),s("li",[t._v("QueuingConsumer 不是事件驱动的")])]),t._v(" "),s("p",[t._v("所以还是使用 "),s("code",[t._v("DefaultConsumer")]),t._v(" 之类的来订阅队列。")])])}),[],!1,null,null,null);n.default=e.exports}}]);